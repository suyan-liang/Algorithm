# 动态规划

## 基本介绍

#### 解题步骤:star:

1. 找出状态和`dp`数组的含义(状态一般通过变化的量或者常数得出。`dp`数组的含义一般就是题目的设问,但也不一定)
2. 考虑答案与`dp`数组的关系(答案不一定就是`dp[M][N]`的形式，也有可能是求`dp`数组的最值)
3. 确定状态转移方程***(核心:就思考最后一次变化，当前的状态可以由哪些已知状态推到)***
4. 编程：枚举所有状态，写状态转移方程还有边界处理，细节处理





#### 三个性质

- 子问题重叠性：就是一个`dp`问题可以被分为多个规模不同的子问题

- 无后效性：已经求解的子问题不会受到后续阶段的影响

- 最优子结构性质：下一阶段的最优解应该能够由前面各阶段子问题的最优解(已知)导出

  看是否具有最优子结构性质来确定`dp`数组的含义,是像`LIS`那样表示以`A[i]`结尾的长度，还是像`LCS`那样是`A[1~i]`这个范围的最值,不过一般是后者



> 1. 动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。
>
>    找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。
>
> 2. **1、遍历的过程中，所需的状态必须是已经计算出来的**。
>
>    **2、遍历的终点必须是存储结果的那个位置**。
>
>    下面来距离解释上面两个原则是什么意思。
>
>    比如编辑距离这个经典的问题，详解见前文「编辑距离详解」，我们通过对 `dp` 数组的定义，确定了 base case 是 `dp[..][0]` 和 `dp[0][..]`，最终答案是 `dp[m][n]`；而且我们通过状态转移方程知道 `dp[i][j]` 需要从 `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]`转移而来，如下图：
>
>    那么，参考刚才说的两条原则，你该怎么遍历 `dp` 数组？肯定是正向遍历：
>
>    ```cpp
>    for (int i = 1; i < m; i++)
>        for (int j = 1; j < n; j++)
>            // 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]
>            // 计算 dp[i][j]
>    ```
>
>    因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案 `dp[m][n]`。
>
> 3. 首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。
>
>    然后根据 dp 数组的定义，运用数学归纳法的思想，假设 $dp[0...i-1]$ 都已知，想办法求出 $dp[i]$，一旦这一步完成，整个题目基本就解决了。
>
>    但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。
>
>    最后想一想问题的 base case 是什么，以此来初始化 dp 数组，以保证算法正确运行。

> [博客](https://mp.weixin.qq.com/s/RXfnhSpVBmVneQjDSUSAVQ)
>
> 状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：
>
> 
>
> ```cpp
> for 状态1 in 状态1的所有取值：
>  for 状态2 in 状态2的所有取值：
>      for ...
>          dp[状态1][状态2][...] = 择优(选择1，选择2...)
> ```

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        /*
          状态，选择，dp数组含义，处理边界
          状态-->背包容量和可选择的数字 -->怎么寻找状态？-->得到dp需要的参数为状态？
          选择-->放或者不放-->怎么从子状态得到当前的状态？
          dp  -->能不能恰好装满 true or false
          处理边界--> 奇数问题，以及装不下的问题
          两个子集的元素和相等<==>一个子集，元素和等于sum/2
         */
         int sum=0;
         for(int i=0;i<nums.size();i++){
             sum+=nums[i];
         }
         if(sum%2!=0) return false;
         int target=sum/2;
         vector<bool> dp(target+1,false);
         dp[0]=true;
         for(int i=0;i<nums.size();i++){
             for(int j=target;j>=nums[i];j--){
              dp[j]=dp[j]||dp[j-nums[i]]; 
         }
         }
         return dp[target];
    }

};
```



## 线性`dp`

#### 1.介绍



#### 2.`LIS`

> `dp[i]`代表以`a[i]`结尾的,意思是`a[i]`肯定在子序列里面,然后求`dp`数组的最值

```CPP
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size()==0) return 0;
        // 确定状态 dp[i]->长度为i时的LIS
        int n=nums.size();
        vector<int> dp(n,1);
        int ans=1;
       
        //枚举所有状态
        for(int i=0;i<nums.size();i++){
            //进行状态转移
            for(int j=0;j<i;j++){//要和原来的相比，看哪个能是最大的
                if(nums[i]>nums[j]){
                    dp[i]=max(dp[i],dp[j]+1);
                    ans=max(dp[i],ans);//求出答案
                }
            }
        }
        return ans;
    }
};
```



#### 3.`LCS`

> `dp[i][j]`代表长度到`i j`，但是并不一定包含在子序列中,答案直接是最后一个`dp`数组

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1=text1.size();
        int len2=text2.size();
        if(len1==0||len2==0) return 0;
        vector<vector<int>> dp(len1+1,vector<int>(len2+1,0)); //等价于dp[i][j]，表示i,j前面的

        //枚举所有状态
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                //进行状态转移
                if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        } 

        //求出答案,注意边界细节之类的东西
        return dp[len1][len2];
    }
};
```

