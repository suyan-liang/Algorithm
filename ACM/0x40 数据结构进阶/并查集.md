# 并查集

> [经典文章](https://blog.csdn.net/niushuai666/article/details/6662911)
>
> 

## 基础模板

```cpp

//pre数组存放第i个元素的父节点
//注意，初始化的时候pre[i]=i;
int pre[1010]; 
 

int find(int root) //查找根结点
{
	int son, tmp;
	son = root;
    //只有根节点的父节点是自己
	while(root != pre[root]) //寻找根结点
		root = pre[root];
    //现在root等于根节点，son是查找的那个
	while(son != root) //路径压缩，把当前那个的pre直接连到root
	{ 
		tmp = pre[son];
		pre[son] = root;
		son = tmp;
	}
	return root;
}
 
void join(int root1, int root2) //判断是否连通，不连通就合并
{
	int x, y;
	x = find(root1);
	y = find(root2);
	if(x != y) //如果不连通，就把它们所在的连通分支合并
		pre[x] = y;
}
```

## 进阶模板

```cpp
//猜拳或者是食物链，这种构成一个循环的题型
//http://oj.haizeix.com/contest/191/problem/72
//https://blog.csdn.net/m0_37579232/article/details/79920785
#include<iostream>
#include<algorithm>
using namespace std;

//pre数组的大小开到三倍maxLen
const int maxLen = 1e4 + 10;
int pre[3*maxLen] = { 0 };

//查找root
int find(int now)
{
	int root;
	int son = now;
	int tmp;
	while (now != pre[now])
	{
		now = pre[now];
	}
	root = now;
	//路径压缩
	while (son != root)
	{
		tmp = pre[son];
		pre[son] = root;
		son = tmp;
	}
	return root;
}

//合并
void join(int a, int b)
{
	int x = find(a);
	int y = find(b);
	if (x != y)
	{
		pre[x] = y;
	}
}
int main()
{
	int n, m;
	cin >> n >> m;
	int a, b, c;
	for (int i = 0; i < 3 * n; i++) pre[i] = i;
	while (m--)
	{
		cin >> a >> b >> c;
		if (a == 1)
		{
            /*
            !!!!!!!!!!!!关键在这里!!!!!!!!!!!!!!!!
            用三倍的数组来表示三种关系
            x+2n吃x+n，x+n吃x，x吃x+2n；y+2n吃y+n，y+n吃y，y吃y+2n
            
            可以理解为每个数所在的组都有三个数字，分别对应着吃的关系
            每知道两个数字的关系，就分别连接到自己的组里面
            这样就可以知道了~
            
            如果x与y同类则
            link(x,y);
            link(x+n,y+n);
            link(x+2*n,y+2*n);
===========================================
            如果x吃y，则
            link(x+2*n,y);
            link(x+n,y+2*n);
            link(x,y+n);
            */
			join(b + 2 * n, c);
			join(b + n, c + 2 * n);
			join(b, c + n);
		}
		if (a == 2)
		{
			if (find(b) == find(c)) cout << "Tie" << endl;
			else if (find(b) == find(c + n)) cout << "Win" << endl;
			else if (find(b + n) == find(c)) cout << "Loss" << endl;
			else cout << "Unknown" << endl;
		}
	}
	return 0;
}
```

