## 线段树

#### 1.是啥

> 1. 二叉树，权值
> 2. https://zhuanlan.zhihu.com/p/79060985
> 3. https://www.jianshu.com/p/90e9bfe4dec0
> 4. https://blog.csdn.net/zearot/article/details/52280189

> 1. 两个数组，一个储存源数据，一个储存要求的区间统计值（线段树）
> 2. 递归建树，递归更新，递归查询。

> start和end是老大帮我算好给我的，是我这个节点管辖的范围
>
> 写函数的时候当做自己是一个节点来处理

```cpp
//不知道对不对

#include<iostream>
#include<algorithm>
using namespace std;


const int maxLen = 10000;

int arr[maxLen]={0,1,3,5,7,9,11 };;
int tree[4 * maxLen + 10];
int n, m;

//建树
//在线段树数组的下标为index,构建数据数组从start到end
void build(int index,int start,int end)
{

	if (start == end)
	{
		tree[index] = arr[start];
		//cout << "start=" << start<<endl;
		//cout << "--------" << tree[index] << "-------" << endl;
	}
	else
	{
		int mid = (start + end) / 2;
		int L = 2 * index;
		int R = 2 * index + 1;
		build(L, start, mid);
		build(R, mid + 1, end);
		//值为左右子节点中大的那个
		tree[index] = max(tree[L], tree[R]);
	}
}


//更新数组，同时更新线段树
void update(int index, int start,int end,int arridx,int val)
{
	if (start == end)
	{
		arr[arridx] = val;
		tree[index] = val;
	}
	else 
	{
		int mid = (start + end) / 2;
		int L = 2 * index;
		int R = 2 * index + 1;
		if (arridx >= start && arridx <= mid)
		{
			update(L, start, mid, arridx, val);
		}
		else
		{
			update(R, mid + 1, end, arridx, val);
		}
		tree[index] = max(tree[L], tree[R]);
	}
}

//查询
int query(int index, int start, int end, int Lrange, int Rrange)
{
	if (start > Rrange || end < Lrange)
	{
		return 0;
	}
	else if (start >= Lrange && end <= Rrange)
	{
		return tree[index];
	}
	else 
	{
		int mid = (start + end) / 2;
		int L = 2 * index;
		int R = 2 * index + 1;
		int maxL = query(L, start, mid, Lrange, Rrange);
		int maxR = query(R, mid + 1, end, Lrange, Rrange);
		return max(maxL, maxR);
	}
}


int main()
{
	cin >> n >> m;
	
	for (int i = 1; i <= n; i++)
	{
		cin >> arr[i];
	}
	build(1, 1, n);
	int a, b, c;
	for (int i = 0; i < m; i++)
	{
		cin >> a >> b >> c;
		if (a == 1)
		{
			update(1,1,n,b,c);
		}
		else
		{
			cout << query(1, 1, n, b, c) << endl;
		}
	}
	return 0;
}
```

