# 模板

## 一、搜索

```cpp
1、BFS:
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记
int dir[4][2]= {0,1,0,-1,1,0,-1,0}; // 方向向量
struct State { // BFS 队列中的状态数据结构
	int x,y; // 坐标位置
	int Step_Counter; // 搜索步数统计器
};
State a[maxn];
bool CheckState(State s) { // 约束条件检验
	if(!vst[s.x][s.y] && ...) // 满足条件
		return 1;
	else // 约束条件冲突
		return 0;
}
void bfs(State st) {
	queue <State> q; // BFS 队列
	State now,next; // 定义2 个状态，当前和下一个
	st.Step_Counter=0; // 计数器清零
	q.push(st); // 入队
	vst[st.x][st.y]=1; // 访问标记
	while(!q.empty()) {
		now=q.front(); // 取队首元素进行扩展
		if(now==G) { // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
			...... // 做相关处理
			return;
		}
		for(int i=0; i<4; i++) {
			next.x=now.x+dir[i][0]; // 按照规则生成下一个状态
			next.y=now.y+dir[i][1];
			next.Step_Counter=now.Step_Counter+1; // 计数器加1
			if(CheckState(next)) { // 如果状态满足约束条件则入队
				q.push(next);
				vst[next.x][next.y]=1; //访问标记
			}
		}
		q.pop(); // 队首元素出队
	}
	return;
}
 
int main() {
	......
	return 0;
}
2、DFS

#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记
int map[maxn][maxn]; // 坐标范围
int dir[4][2]= {0,1,0,-1,1,0,-1,0}; // 方向向量，(x,y)周围的四个方向
 
bool CheckEdge(int x,int y) { // 边界条件和约束条件的判断
	if(!vst[x][y] && ...) // 满足条件
		return 1;
	else // 与约束条件冲突
		return 0;
}
 
void dfs(int x,int y) {
	vst[x][y]=1; // 标记该节点被访问过
	if(map[x][y]==G) { // 出现目标态G
		...... // 做相应处理
		return;
	}
	for(int i=0; i<4; i++) {
		if(CheckEdge(x+dir[i][0],y+dir[i][1])) // 按照规则生成下一个节点
			dfs(x+dir[i][0],y+dir[i][1]);
	}
	return; // 没有下层搜索节点，回溯
}
int main() {
	......
	return 0;
}
```

## 二、dp

### 1.背包

```cpp
动态规划--背包问题模板
#include <iostream>
#include <cstdio>
#include <complex>
#define A 1000010
using namespace std;
int f[A], w[A], v[A];//分别代表最优解，重量和空间
//输入的时候从1开始
/*---------0-1背包----------*/
int knapsack01(int n, int V) {
    memset(f, 0xc0c0c0c0, sizeof f); f[0] = 0; //需要装满
    memset(f, 0, sizeof f); //不需要装满 
    for (int i = 1; i <= n; i++)
        for (int j = V; j >= w[i]; j--)
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    return f[V];
}
/*-----------完全背包----------*/
int Fullbackpack(int n, int V) {
    for (int i = 1; i <= n; i++)
        for (int j = w[i]; j <= V; j++)
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    return f[V];
}
/*-------多重背包二进制拆分-------*/
int number[A];
int MultiplePack1(int n, int V) {
    for (int i = 1; i <= n; i++) {
        int num = min(number[i], V / w[i]);
        for (int k = 1; num > 0; k *= 2) {
            if (k > num) k = num;
            num -= k;
            for (int j = V; j >= w[i] * k; j--)
            f[j] = max(f[j], f[j - w[i] * k] + v[i] * k);
        }
    }
    return f[V];
}
int newv[A], neww[A], cnt;
int MultiplePack2(int n, int V) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= c[i]; j <<= 1) {
            newv[cnt] = j * v[i];
            neww[cnt++] = j * w[i];
            c[i] -= j;
        }
        if (c[i] > 0) {
            newv[cnt] = c[i] * v[i];
            neww[cnt++] = c[i] * w[i];
        }
    }
    for (int i = 1; i <= cnt; i++)
	    for (int j = V; j >= neww[i]; j--)
	        f[j] = max(f[j], f[j - neww[i]] + newv[i]);
	return f[V];
}
/*------------多重背包单调队列优化------------*/
void MultiPack(int p, int w, int v) {
    for (int j = 0; j < cost; j++) {
        int head = 1,tail = 0;
        for (int k = j, i = 0; k <= V / 2; k += w, i++) {
            int r = f[k] - i * v;
            while (head <= tail and r >= q[tail].v) tail--;
            q[++tail] = node(i, r);
            while (q[head].id < i - num) head++;
            f[k] = q[head].v + i * v;
        }
    }
}
/*-----------二维费用背包----------*/
int t[A], g[A], dp[B][B];
int Costknapsack(int n, int V, int T) {
    for (int i = 1; i <= n; i++)
        for (int j = T; j >= w[i]; j--)
            for (int k = V; k >= g[i]; k--)
                dp[j][k] = max(dp[j][k], dp[j - w[i]][k - g[i]] + v[i]);
	return dp[T][V];
}
/*--------------分组背包--------------*/
int a[B][B];
int Groupingbackpack() {
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 0; j--)
            for (int k = 1; k <= j; k++)
                f[j] = max(f[j], f[j - k] + a[i][k]);
    return f[m];
}
/*------------K优解---------------*/
int kth(int n, int V, int k) {
	for (int i = 1; i <= n; i++) {
	  for (int j = V; j >= w[i]; j--) {
	  	for (int l = 1; l <= k; l++) {
	  		a[l] = f[j][l];
	  		b[l] = f[j - w[i]][l] + v[i];
			}
			a[k + 1] = -1;
			b[k + 1] = -1;
			int x = 1, y = 1, o = 1;
			while (o != k + 1 and (a[x] != -1 or b[y] != -1)) {
				if (a[x] > b[y]) f[j][o] = a[x], x++;
				else f[j][o] = b[y], y++;
				if (f[j][o] != f[j][o - 1]) o++;
			}
		}
	}
	return f[V][k];
}
```

### 2.区间dp

```cpp
2、区间DP模板
特征：区间合并有花费
//n是区间长度，dp[i][j]存从i 到 j 区间合并的最优值
//w[i][j]表示从i 到 j的花费，有时候w[i][j]也可以用sum数组（从1到n）的差

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int main()
{
    int i, j, n, k, len, st;
    int sum[205] = {0};//sum[i]存合并前n石子的花费
    int dp[205][205];
    memset(dp, 0x3f, sizeof(dp));//初始化为较大数值以更新
    scanf("%d", &n);
    for(i = 1;i <= n;i++){
        scanf("%d", &st);
        dp[i][i] = 0;//合并一堆石子不需要花费
        sum[i] = sum[i - 1] + st;//求sum数组
    }
    for(len = 2;len <= n;len++){
        for(i = 1;i < n;i++){
            j = i + len - 1;//计算区间终点
            if(j > n)//越界跳出
                break;
            for(k = i;k < j;k++)
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]);
        }
    }
    printf("%d\n", dp[1][n]);
    return 0;
}



平行四边形优化后的区间DP
//n是区间长度，dp[i][j]存从i 到 j 区间合并的最优值
//w[i][j]表示从i 到 j的花费， s[i][j]记录从i 到 j的最优分割点
for(i = 1;i <= n;i++){
    dp[i][i] = 初始值；
    s[i][i] = i;
}
for(len = 2;len <= n;len++){//len选择区间长度
    for(i = 1;i <= n;i++){//枚举起点
        j = i + len - 1;//合并终点
        if(j > n)break;//不可越界
        for(k = s[i][j - 1];k < s[i + 1][j];k++)//在最优分割点范围内枚举分割点
            if(dp[i][j] > dp[i][k] + dp[k + 1][j] + w[i][j]){
                dp[i][j] = dp[i][k] + dp[k + 1][j] + w[i][j];
                s[i][j] = k;//更新最佳分割点
            }
    }
}
```

### 3.子序列

```cpp
1、最长连续子序列和
int MaxSubSequence(const int A[], int N)
{
    int ThisSum,MaxSum,j;
    ThisSum = MaxSum =0;
    for(j = 0;j < N;j++)
    {
        ThisSum += A[j];

        if(ThisSum > MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum < 0)
            ThisSum = 0; 
    }
    return MaxSum; 
} 
2、最长上升子序列
int LIS(int ar[],int n)   //最长上升子序列长 
{
    int ans=1;
    for(int i=0;i<n;i++)
    {
        dp[i]=1;
        for(int j=0;j<i;j++)
            if(ar[j]<ar[i]) dp[i]=max(dp[i],dp[j]+1);
            ans=max(ans,dp[i]);
    }
    return ans;
}
3.最长公共子序列
        n=strlen(a);
        m=strlen(b);
        memset(dp,0,sizeof(dp));
        for(int k=1; k<=n; k++)
        {
            for(int j=1; j<=m; j++)
            {
                if(a[k-1]==b[j-1])
                    dp[k][j]=dp[k-1][j-1]+1;
                else
                    dp[k][j]=max(dp[k-1][j],dp[k][j-1]);
            }
 
        }
        printf("%d\n",dp[n][m]);
```

## 三、图论

```cpp
1、prim算法
// st[i] 表示点i是否在当前生成树集合中
// dist[i] 表示点i到当前集合的最短边的长度
// g[i][j] 表示点i和点j之间边的长度
// 返回值：最小生成树中所有边的总长度
int Prim()
{
    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        dist[i] = INF;
        st[i] = false;
    }
    dist[1] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int id = -1, min_dist = INF;
        // 寻找最短边
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && dist[j] < min_dist)
            {
                id = j;
                min_dist = dist[j];
            }
        st[id] = true;
        res += dist[id];
        // 用新加入的点更新其余点到生成树的最短边
        for (int j = 1; j <= n; j ++ )
            if (!st[j])
                dist[j] = min(dist[j], g[id][j]);
    }
    return res;
}
2、Kruskal算法
// 边的信息
struct Edge
{
    int a, b, v;
    bool operator< (const Edge &W) const
    {
        return v < W.v;
    }
};

// 并查集——寻找当前集合的代表元素
int find(int x)
{
    if (father[x] != x) father[x] = find(father[x]);
    return father[x];
}

// 所有边存储在 Edge edges[M]; 
// 函数返回最小生成树中所有边的总长度
int Kruskal()
{
    int res = 0;
    // 初始化并查集代表元素
    for (int i = 1; i <= n; i ++ ) father[i] = i;
    sort(edge, edge + m);
    for (int i = 0; i < m; i ++ )
    {
        int a = edge[i].a, b = edge[i].b;
        if (find(a) != find(b))
        {
            res += edge[i].v;
            father[find(a)] = find(b);
        }
    }
    return res;
}
3、迪杰斯特拉算法
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 2000010, INF = 1000000000;

int n, m;
int g[N][N], dist[N];
bool st[N];

void dijkstra()
{
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    for (int i = 0; i < n; i++)
    {
        int id, mind = INF;
        for (int j = 1; j <= n; j++)
            if (!st[j] && dist[j] < mind)
            {
                mind = dist[j];
                id = j;
            }
        st[id] = 1;
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], dist[id] + g[id][j]);
    }
}

int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            g[i][j] = INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    dijkstra();
    cout << dist[n] << endl;
    return 0;
}
4、弗洛伊德算法
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 1010, M = 2000010, INF = 1000000000;

int n, m;
int d[N][N];

int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```

## 四、字符串

### 1.KMP

```cpp
1、KMP算法
/*这个模板 字符串是从0开始的
Next数组是从1开始的
*/
#include <iostream>
#include <cstring>
using namespace std;
 
const int N = 1000002;
int next[N];
char S[N], T[N];
int slen, tlen;
 
void getNext()
{
    int j, k;
    j = 0; k = -1; next[0] = -1;
    while(j < tlen)
        if(k == -1 || T[j] == T[k])
            next[++j] = ++k;
        else
            k = next[k];
 
}
/*
返回模式串T在主串S中首次出现的位置
返回的位置是从0开始的。
*/
int KMP_Index()
{
    int i = 0, j = 0;
    getNext();
 
    while(i < slen && j < tlen)
    {
        if(j == -1 || S[i] == T[j])
        {
            i++; j++;
        }
        else
            j = next[j];
    }
    if(j == tlen)
        return i - tlen;
    else
        return -1;
}
/*
返回模式串在主串S中出现的次数
*/
int KMP_Count()
{
    int ans = 0;
    int i, j = 0;
 
    if(slen == 1 && tlen == 1)
    {
        if(S[0] == T[0])
            return 1;
        else
            return 0;
    }
    getNext();
    for(i = 0; i < slen; i++)
    {
        while(j > 0 && S[i] != T[j])
            j = next[j];
        if(S[i] == T[j])
            j++;
        if(j == tlen)
        {
            ans++;
            j = next[j];
        }
    }
    return ans;
}
int main()
{
    
    int TT;
    int i, cc;
    cin>>TT;
    while(TT--)
    {
        cin>>S>>T;
        slen = strlen(S);
        tlen = strlen(T);
        cout<<"模式串T在主串S中首次出现的位置(按数组说)是: "<<KMP_Index()<<endl;
        cout<<"模式串T在主串S中出现的次数为: "<<KMP_Count()<<endl;
    }
    return 0;
}
```

## 五、其他

```cpp
3、二分查找模板
版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。

C++ 代码模板：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
版本2
当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。

C++ 代码模板：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
4、桶排序模板
#include <iostream>
#include <vector>
#include <algorithm>
 
using namespace std;
 
void bksort(float A[],int l,int h){
    int size = h-l+1;
    vector<float> b[size];//有size个数据，就分配size个桶
    for(int i=l;i<=h;i++){
        int bi = size*A[i];//元素A[i]的桶编号
        b[bi].push_back(A[i]);//将元素A[i]压入桶中
    }
    for(int i=0;i<size;i++)
        sort(b[i].begin(),b[i].end());//桶内排序
    int idx = l;//指向数组A的下标
    for(int i=0;i<size;i++){//遍历桶
        for(int j=0;j<b[i].size();j++){//遍历桶内元素
            A[idx++] = b[i][j];
        }
    }
}
 
int main(){
    float A[] = {0.78,0.17,0.39,0.26,0.72,0.94,0.21,0.12,0.23,0.68};
    bksort(A,0,9);
    for(int i=0;i<10;i++)
        cout<<A[i]<<" ";
}


快速幂模板
求 mk%p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}

高精度模板
1、加法
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
string add(string a,string b)//只限两个非负整数相加  
{  
    string ans;  
    int na[L]={0},nb[L]={0};  
    int la=a.size(),lb=b.size();  
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';  
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';  
    int lmax=la>lb?la:lb;  
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;  
    if(na[lmax]) lmax++;  
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';  
    return ans;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<add(a,b)<<endl;  
    return 0;  
}
3、减法
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
string sub(string a,string b)//只限大的非负整数减小的非负整数  
{  
    string ans;  
    int na[L]={0},nb[L]={0};  
    int la=a.size(),lb=b.size();  
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';  
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';  
    int lmax=la>lb?la:lb;  
    for(int i=0;i<lmax;i++)  
    {  
        na[i]-=nb[i];  
        if(na[i]<0) na[i]+=10,na[i+1]--;  
    }  
    while(!na[--lmax]&&lmax>0)  ;lmax++;  
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';  
    return ans;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<sub(a,b)<<endl;  
    return 0;  
} 
4、乘法
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
string mul(string a,string b)//高精度乘法a,b,均为非负整数  
{  
    string s;  
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积  
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0  
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数  
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';  
    for(int i=1;i<=La;i++)  
        for(int j=1;j<=Lb;j++)  
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）  
    for(int i=1;i<=La+Lb;i++)  
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位  
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0  
    for(int i=La+Lb-1;i>=1;i--)  
        s+=nc[i]+'0';//将整形数组转成字符串  
    return s;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<mul(a,b)<<endl;  
    return 0;  
}  
5、除法
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
int sub(int *a,int *b,int La,int Lb)  
{  
    if(La<Lb) return -1;//如果a小于b，则返回-1  
    if(La==Lb)  
    {  
        for(int i=La-1;i>=0;i--)  
            if(a[i]>b[i]) break;  
            else if(a[i]<b[i]) return -1;//如果a小于b，则返回-1  
  
    }  
    for(int i=0;i<La;i++)//高精度减法  
    {  
        a[i]-=b[i];  
        if(a[i]<0) a[i]+=10,a[i+1]--;  
    }  
    for(int i=La-1;i>=0;i--)  
        if(a[i]) return i+1;//返回差的位数  
    return 0;//返回差的位数  
  
}  
string div(string n1,string n2,int nn)//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数  
{  
    string s,v;//s存商,v存余数  
     int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;//a，b是整形数组表示被除数，除数，tp保存被除数的长度  
     fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0  
     for(i=La-1;i>=0;i--) a[La-1-i]=n1[i]-'0';  
     for(i=Lb-1;i>=0;i--) b[Lb-1-i]=n2[i]-'0';  
     if(La<Lb || (La==Lb && n1<n2)) {  
            //cout<<0<<endl;  
     return n1;}//如果a<b,则商为0，余数为被除数  
     int t=La-Lb;//除被数和除数的位数之差  
     for(int i=La-1;i>=0;i--)//将除数扩大10^t倍  
        if(i>=t) b[i]=b[i-t];  
        else b[i]=0;  
     Lb=La;  
     for(int j=0;j<=t;j++)  
     {  
         int temp;  
         while((temp=sub(a,b+j,La,Lb-j))>=0)//如果被除数比除数大继续减  
         {  
             La=temp;  
             r[t-j]++;  
         }  
     }  
     for(i=0;i<L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位  
     while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的  
     while(i>=0) s+=r[i--]+'0';  
     //cout<<s<<endl;  
     i=tp;  
     while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的</span>  
     while(i>=0) v+=a[i--]+'0';  
     if(v.empty()) v="0";  
     //cout<<v<<endl;  
     if(nn==1) return s;  
     if(nn==2) return v;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<div(a,b,1)<<endl;  
    return 0;  
} 
```

## 六、STL

```cpp
函数
1、sort函数
排序
如果从大到小bool compare(int a,int b) { return a>b; }
如果结构体bool cmp(node x,node y) { if(x.a!=y.a) return x.a<y.a; if(x.b!=y.b) return x.b>y.b; return x.c>y.c; }
2、unique
去重函数,用前必须排序，返回最后一位不同的数的下标
Unique(a,a+n)-a表示去重后的数组长度
3、binary_search函数
Binary_search(a,a+6,4)  在区间里查找4 bool 类型
4、lower_bound(a,a+6,3) 返回≥3的第一个数的迭代器
Upper_bound(a,a+6,3)  ......＞3.。。。。。。
容器
```

