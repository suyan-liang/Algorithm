# 高精度加法



注意的点

- 存储方向
- 进位处理
- 输出

过程
- 进行加法
- 进行进位


看情况
- 如果是从小到大进行运算比如说斐波那契数列这样的，可以使用二维的int数组来进行模拟
- 如果是直接a+b这种，那就必须得使用字符串进行存储了





#### 字符串存储

```cpp
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;


const int N=5000;
int f[N+10]={0};

int main(){
    string a,b,ans;
    cin>>a>>b;
    int alen=a.size();
    int blen=b.size();
    if(alen<blen){
        int tmp=blen-alen;
        for(int i=0;i<tmp;i++){
            a="0"+a;
        }
    }else{
        int tmp=alen-blen;
        for(int i=0;i<tmp;i++){
            b="0"+b;
        }
    }
    int len=a.size();
    int tmp;
    int cf=0;//进位
    for(int i=len-1;i>=0;i--){
        tmp=a[i]+b[i]-2*'0';
        cf=tmp/10;
        tmp%=10;
        ans=char(tmp+'0')+ans;
    }
    if(cf>0) ans="1"+ans;
    cout<<ans<<endl;
    
    return 0;
}
```


#### 二维数组存储
1
```cpp

#include<iostream>
#include<algorithm>
using namespace std;


const int N=5000;
long long f[N+10][1200];

int main(){
    
    
    int n;
    cin>>n;
    f[0][1]=0;
    f[1][1]=1;
    f[2][1]=2;
    if(n<3){
         cout<<f[n][1]<<endl;
         return 0;
    }
    else{
        for(int i=3;i<=n;i++){
            //进行高精度加法
            
            for(int j=1;j<=1200;j++){
                f[i][j]=f[i-1][j]+f[i-2][j];
            }
            
            for(int j=1;j<=1200;j++){
                while(f[i][j]>9){
                    f[i][j+1]++;
                    f[i][j]-=10;
                }
            }
        }
        
        
        bool find=false;
        //输出 。也是因为之前有了1200位的限制，所以可以从后往前进行输出
        for(int j=1200;j>=1;j--){
            if(!find && f[n][j]==0) continue;
            find = true;
            cout<<f[n][j];
        }
    }
    

    
    return 0;
}
```

2 更新len,更加具有普适性
```cpp

#include<iostream>
#include<algorithm>
using namespace std;


const int N=5000;
long long f[N+10][1200];
int len=1;

void add(int i){
    for(int j=1;j<=len;j++) f[i][j]=f[i-1][j]+f[i-2][j];
    int j;
    for(j=1;j<=len;j++){
        if(f[i][j]>9){
            f[i][j+1]+=f[i][j]/10; 
            f[i][j]%=10;
        }
    }
    if(f[i][j]>0) len=j;
}
int main(){
    
    int n;
    cin>>n;
    f[0][1]=0;
    f[1][1]=1;
    f[2][1]=2;
    if(n<3){
         cout<<f[n][1]<<endl;
         return 0;
    }
    else{
        for(int i=3;i<=n;i++){
            //进行高精度加法
            add(i);
        }
        for(int i=len;i>=1;i--){
            cout<<f[n][i];
        }
    }
    

    
    return 0;
}
```