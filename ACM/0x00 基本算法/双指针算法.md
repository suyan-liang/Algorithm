## 双指针算法

#### 1.介绍

> ```c++
> 2. 双指针算法
> 	for (int i = 0, j = 0; i < n; i ++ )
> 	{
> 		while (j < i && check(i, j)) j ++ ;
> 		
> 		// 具体问题的逻辑
> 	}
> 	常见问题分类：
> 		(1) 对于一个序列，用两个指针维护一段区间
> 		(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
> ```
>
> ![image-20200502101307402](C:\Users\liang\AppData\Roaming\Typora\typora-user-images\image-20200502101307402.png)

#### 2.入门题

> ```c++
> /*
> 输入一个字符串，将其中的单词输出出来，假定两个单词之间间隔一个空格且字符串起始不是空格
> */
> 
> #include<iostream>
> #include<string>
> using namespace std;
> int main() {
> 	string str;
> 	cin >> str;
> 	//就好像大王派小弟去探路啊哈哈哈
> 	//大王派我去巡山~
> 	for (int i = 0; i < str.size(); i++) {
> 		int j = i;
> 		while (j < str.size() && str[j] != ' ') j++;
> 		for (int k = i; k < j; k++) {
> 			cout << str[k];
> 		}
> 		cout << endl;
> 		i = j;
> 	}
> 	return 0;
> }
> ```
>
> 

#### 3.思想

> 1. 根据性质去优化
>
> 2. 朴素算法一般是O(n^2) ,双指针算法的题一般是能找到一些性质，能使得j并不遍历所有n，而是在i的前提下去做一些判断啊，移动啊。
>
> 3. 先考虑朴素解法，再考虑剪枝和优化
>
> 4. 双指针一般也要求有序，单调。
>
>    ```cpp
>    class Solution {
>    public:
>        vector<vector<int>> threeSum(vector<int>& nums) {
>            vector<vector<int>> res;
>            sort(nums.begin(),nums.end());
>            for(int i=0;i<nums.size();i++){
>                int target=-nums[i];
>                 int j=i+1,k=nums.size()-1;
>                 while(j<=k){
>                     if(nums[j]+nums[k]<target){
>                         j--;
>                     }else if(nums[j]+nums[k]>target){
>                         i++;
>                     }
>                     else{
>    
>                         res.push_back({nums[k], nums[i], nums[j]});
>                     }
>                     while(nums[i]==nums[i-1]) i++;
>                     while(nums[j]==nums[j+1]) j--;
>                 }
>            }
>            return res;
>        }
>    };
>    
>    class Solution {
>    public:
>        vector<vector<int>> threeSum(vector<int>& nums) {
>            vector<vector<int>> res;
>            sort(nums.begin(),nums.end());
>            if (nums.empty() || nums.back() < 0 || nums.front() > 0) return {};
>            for(int k=0;k<nums.size()-2;k++){
>                if(nums[k]>0) break;
>                if (k > 0 && nums[k] == nums[k - 1]) continue;
>                int target=-nums[k];
>                int i=k+1,j=nums.size()-1;
>                while (i < j) {
>                    if (nums[i] + nums[j] == target) {
>                        res.push_back({nums[k], nums[i], nums[j]});
>                        while (i < j && nums[i] == nums[i + 1]) ++i;
>                        while (i < j && nums[j] == nums[j - 1]) --j;
>                        ++i; --j;
>                    } else if (nums[i] + nums[j] < target) ++i;
>                    else --j;
>                }
>            }
>            return res;
>        }
>    };
>    ```
>
>    