## 二分

### 1.模板

> ```c++
> 
> //前提，二分一定是有序的
> 
> //更新的时候l比r大1
> //只有l=mid或者r=mid l=mid的时候要在mid上补1
> 
> // 整数二分算法模板
> 
> bool check(int x) {/* ... */} // 检查x是否满足某种性质
> 
> //找绿色区间边界
> // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
> 
> int bsearch_1(int l, int r)
> {
>  while (l < r)
>  {
>      int mid = l + r >> 1;
>      if (check(mid)) r = mid;    // check()判断mid是否满足性质
>      else l = mid + 1;
>  }
>  return l;
> }
> 
> //找红色区间边界
> // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
> //这里补上1是因为如果不补，当l=r-1，且check成功，会发生死循环
> int bsearch_2(int l, int r)
> {
>  while (l < r)
>  {
>      int mid = l + r + 1 >> 1;
>      if (check(mid)) l = mid;
>      else r = mid - 1;
>  }
>  return l;
> }
> 
> 
> 
> // 浮点数二分算法模板
> 
> bool check(double x) {/* ... */} // 检查x是否满足某种性质
> 
> double bsearch_3(double l, double r)
> {
>  //一般来说，取x位小数，eps取x+2位保险
>  const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
>  while (r - l > eps)
>  {
>      double mid = (l + r) / 2;
>      if (check(mid)) r = mid;
>      else l = mid;
>  }
>  return l;
> }
> 
> ```
>
> 

#### 2.介绍

> 1. 只要单调，就可以二分出定义性质的边界点
>
> 2. 毕竟是单调，所以脑子里面有下面这个图就好了
>
> 3. ![image-20200502082035611](C:\Users\liang\AppData\Roaming\Typora\typora-user-images\image-20200502082035611.png)
>
> 4. 一般来说，一次二分能定一个边界，要定两个边界，一般上面两个板子都要用。
>
>    思考方式，确定左边界需要一次二分，确定右边界也需要一次二分。先敲上板子，思考一个可以找出左边界的性质，然后看更新方式，根据为true的更新方式写出另一个
>
> 5. 每次更新保证答案在区间里面
>
> 6. 二分一定有解，二分一般的判断是范围判断，是找到第一个符合搜索条件的边界点，是大于等于之类，所以如果二分出来的边界是大于x，那根据题意判断是否得到的这个边界符合题意

>
>
>```cpp
>class Solution {
>public:
>    int search(vector<int>& nums, int target) {
>        /*
>        使用二分进行搜索
>        由于数组进行过旋转，那么主要考虑check函数
>        check函数为mid值是否小于等于最右边的值，如果小于等于说明右半边有序，在右半边进行搜索
>        否则在左半边搜索
>        在半边搜索的时候再进行目标值的查找
>         */
>         if(nums.size()<=0) return -1;
>         if(nums.size()==1) return target==nums[0]?0:-1;
>         int l=0,r=nums.size()-1;
>         while(l<r){
>             int mid=(l+r)>>1;
>             if(nums[mid]<=nums[nums.size()-1]){
>                 if(nums[mid]<=target&&nums[r]>=target){
>                     l=mid;
>                 }else{
>                     r=mid-1;
>                 }
>             }else{
>                  if (nums[l] <= target && nums[mid] > target) r = mid;
>                  else l=mid+1;
>             }
>         }
>         return nums[l] == target ? l:-1;
>    }
>    
>};
>
>class Solution {
>public:
>    int search(vector<int>& nums, int target) {
>        int n = nums.size();
>        if(n==0)
>            return -1;
>        int r = n-1;
>        int l = 0;
>        while(l<r)
>        {
>            int mid = (r-l)/2+l;
>            if(nums[mid]>=nums[l])
>            {
>                if(nums[l]<=target && target<=nums[mid])
>                    r=mid;
>                else
>                    l=mid+1;
>            }
>            else
>            {
>                if(nums[mid+1]<=target && nums[r]>=target)
>                    l=mid+1;
>                else
>                    r=mid;
>            }
>        }
>        return nums[l] == target ? l:-1;
>    }
>};
>
>作者：pang-xie-3
>链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/cmo-ban-er-fen-fa-si-lu-qing-xi-bu-yi-cuo-by-pang-/
>来源：力扣（LeetCode）
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
>```
>
>```cpp
>class Solution {
>public:
>    int search(vector<int>& nums, int target) {
>        /*
>        使用二分进行搜索
>        由于数组进行过旋转，那么主要考虑check函数
>        check函数为mid值是否小于等于最右边的值，如果小于等于说明右半边有序，在右半边进行搜索
>        否则在左半边搜索
>        在半边搜索的时候再进行目标值的查找
>         */
>         if(nums.size()<=0) return -1;
>         if(nums.size()==1) return target==nums[0]?0:-1;
>         int l=0,r=nums.size()-1;
>         while(l<r){
>             int mid=(l+r)>>1;
>             if(nums[mid]<nums[nums.size()-1]){
>                 if(nums[mid]<=target&&nums[r]>=target){
>                     l=mid;
>                 }else{ 
>                     r=mid-1;
>                 }
>             }else{
>                  if (nums[l] <= target && nums[mid] > target) r = mid;
>                  else l=mid+1;
>             }
>         }
>         return nums[l] == target ? l:-1;
>    }
>    
>};
>```
>
>