

#### B. [01 Game](https://codeforces.com/contest/1373/problem/B)

##### [博客](https://blog.csdn.net/jziwjxjd/article/details/106966365)

##### 复盘

```
看到了相邻的两个不同字符删除，觉得很麻烦，但实际上这种类型的题大概率都有规律，不会让你模拟去找

规律？ --> 能够操作的次数
```

##### 扫思路

```
0和1只要存在，那肯定存在相邻的地方
然后我们就无需思考在哪个位置删除，那我们能考虑的只有删除的次数
删除的次数=min(0的个数，1的个数)
可以发现，当可操作的次数为奇数时，Alice会赢。
```

```
这种类似于博弈论的题都会很精妙，不会让你蛮算。要找到里面的规律，找到就赢了。
```

```cpp
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int main() {
	int t;
	cin >> t;
	string str;
	while (t--) {
		cin >> str;
		int num1=0, num0=0;
		for (int i = 0; i < str.size(); i++) {
			if (str[i] == '0') num0++;
			if (str[i] == '1') num1++;
		}
		if (num0 == 0 || num1 == 0) {
			cout << "NET" << endl;
			continue;
		}
		int cal = min(num0, num1);
		if (cal % 2 == 1) cout << "DA" << endl;
		else cout << "NET" << endl;
	}
	return 0;
}
```

